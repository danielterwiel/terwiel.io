## 2026-01-16: inv-02 - use-stack-simulation.ts investigation

### Status: PASSED (no bugs found)

### Summary
Investigated RAF throttling, tick batching, position cache, and simulation reheat patterns
in use-stack-simulation.ts. All implementations follow D3 best practices.

### Findings
1. **RAF throttling (16ms)**: CORRECT - D3 timer already uses RAF internally, so the
   additional 16ms check is redundant but harmless. No adaptive throttle needed for ~30 nodes.

2. **TICKS_PER_FRAME=2**: CORRECT - Backed by D3 research: "force layout is pure math"
   so multiple ticks per frame is valid. 2 is conservative for small node count.

3. **Position cache (0.5px threshold)**: CORRECT - Sub-pixel changes are imperceptible.
   Cache properly includes scaleFactor for invalidation.

4. **alphaTarget patterns**: CORRECT - Values kept low (0.03-0.1) to prevent jitter.
   setTimeout properly resets to 0. isSettlingRef properly tracks settling state.

5. **collide.initialize()**: ACCEPTABLE - O(n) operation but only called when scales
   actually change (hasChanges guard). Cheap for ~30 nodes.

### References consulted
- https://d3js.org/d3-force/simulation
- https://github.com/d3/d3-force/issues/111
- https://github.com/twosixlabs/d3-force-reuse

### Notes
- Pre-existing typecheck errors in root-node-chart.tsx (missing d3 types, implicit any)
- Lint passes after formatting prd.json

## 2026-01-16: inv-03 - stack-cloud utils investigation

### Status: BUGS FOUND

### Summary
Investigated all stack-cloud utils: adaptive-physics.ts, create-forces.ts, boundary-force.ts,
root-exclusion-force.ts, mass-dampen-force.ts, calculate-stack-size.ts, performance-utils.ts,
selection-index.ts, seed-position.ts, distribute-nodes-in-segment.ts, calculate-domain-angles.ts,
convert-arc-angle.ts, calculate-base-radius.ts.

### Bugs Found

1. **mass-dampen-force.ts - INCORRECT D3 FORCE PATTERN**
   - Returns `force(alpha) -> (nodes) -> void` but D3 expects `force(alpha) -> void`
   - D3 forces should receive nodes via `.initialize()` method, not as a parameter
   - Result: Force is a NO-OP because D3 never invokes the inner function
   - Impact: Mass-based velocity dampening is not being applied to nodes

2. **calculate-base-radius.ts - REDUNDANT WORK**
   - Calls `extractUniqueStacks(PROJECTS)` and `calculateStackSizeFactors(PROJECTS)` on every resize
   - These are already computed and memoized in stack-cloud-content.tsx
   - Should accept pre-computed stacks/sizeFactors as parameters
   - Impact: Unnecessary O(n) work + date parsing on every viewport resize

### Correct Implementations
- adaptive-physics.ts: Pure O(1) functions, properly debounced
- create-forces.ts: Force recreation is lightweight, only on resize
- boundary-force.ts: O(n) per tick but simple math, has .update() method
- root-exclusion-force.ts: Standard D3 pattern with Math.sqrt
- selection-index.ts: True O(1) lookups via Set/Map
- performance-utils.ts: Position cache is efficient
- Other utils: Pure math functions, cheap O(1)

### References consulted
- https://d3js.org/d3-force/simulation (custom force pattern documentation)

### Notes
- Pre-existing typecheck errors unchanged
- Lint passes
