## 2026-01-16: inv-02 - use-stack-simulation.ts investigation

### Status: PASSED (no bugs found)

### Summary
Investigated RAF throttling, tick batching, position cache, and simulation reheat patterns
in use-stack-simulation.ts. All implementations follow D3 best practices.

### Findings
1. **RAF throttling (16ms)**: CORRECT - D3 timer already uses RAF internally, so the
   additional 16ms check is redundant but harmless. No adaptive throttle needed for ~30 nodes.

2. **TICKS_PER_FRAME=2**: CORRECT - Backed by D3 research: "force layout is pure math"
   so multiple ticks per frame is valid. 2 is conservative for small node count.

3. **Position cache (0.5px threshold)**: CORRECT - Sub-pixel changes are imperceptible.
   Cache properly includes scaleFactor for invalidation.

4. **alphaTarget patterns**: CORRECT - Values kept low (0.03-0.1) to prevent jitter.
   setTimeout properly resets to 0. isSettlingRef properly tracks settling state.

5. **collide.initialize()**: ACCEPTABLE - O(n) operation but only called when scales
   actually change (hasChanges guard). Cheap for ~30 nodes.

### References consulted
- https://d3js.org/d3-force/simulation
- https://github.com/d3/d3-force/issues/111
- https://github.com/twosixlabs/d3-force-reuse

### Notes
- Pre-existing typecheck errors in root-node-chart.tsx (missing d3 types, implicit any)
- Lint passes after formatting prd.json

## 2026-01-16: inv-03 - stack-cloud utils investigation

### Status: BUGS FOUND

### Summary
Investigated all stack-cloud utils: adaptive-physics.ts, create-forces.ts, boundary-force.ts,
root-exclusion-force.ts, mass-dampen-force.ts, calculate-stack-size.ts, performance-utils.ts,
selection-index.ts, seed-position.ts, distribute-nodes-in-segment.ts, calculate-domain-angles.ts,
convert-arc-angle.ts, calculate-base-radius.ts.

### Bugs Found

1. **mass-dampen-force.ts - INCORRECT D3 FORCE PATTERN**
   - Returns `force(alpha) -> (nodes) -> void` but D3 expects `force(alpha) -> void`
   - D3 forces should receive nodes via `.initialize()` method, not as a parameter
   - Result: Force is a NO-OP because D3 never invokes the inner function
   - Impact: Mass-based velocity dampening is not being applied to nodes

2. **calculate-base-radius.ts - REDUNDANT WORK**
   - Calls `extractUniqueStacks(PROJECTS)` and `calculateStackSizeFactors(PROJECTS)` on every resize
   - These are already computed and memoized in stack-cloud-content.tsx
   - Should accept pre-computed stacks/sizeFactors as parameters
   - Impact: Unnecessary O(n) work + date parsing on every viewport resize

### Correct Implementations
- adaptive-physics.ts: Pure O(1) functions, properly debounced
- create-forces.ts: Force recreation is lightweight, only on resize
- boundary-force.ts: O(n) per tick but simple math, has .update() method
- root-exclusion-force.ts: Standard D3 pattern with Math.sqrt
- selection-index.ts: True O(1) lookups via Set/Map
- performance-utils.ts: Position cache is efficient
- Other utils: Pure math functions, cheap O(1)

### References consulted
- https://d3js.org/d3-force/simulation (custom force pattern documentation)

### Notes
- Pre-existing typecheck errors unchanged
- Lint passes

## 2026-01-16: inv-04 - forceManyBody theta and Barnes-Hut investigation

### Status: PASSED (no actionable bugs)

### Summary
Investigated forceManyBody theta parameter, Barnes-Hut approximation benefits, d3-force-reuse
library applicability, and charge strength calculations for ~30 node simulation.

### Findings

1. **theta=0.5 SUBOPTIMAL BUT HARMLESS**
   - D3 default is 0.9, Barnes-Hut research recommends 1.0 for best accuracy/performance
   - Per jheer.github.io/barnes-hut: theta=0.5 does NOT outperform naive O(n²) until ~6000 nodes
   - At ~30 nodes, quadtree overhead may actually slow things down vs naive approach
   - Impact: Negligible at this scale

2. **d3-force-reuse NOT BENEFICIAL**
   - Library caches quadtree and recalculates every 13 ticks
   - At ~30 nodes, quadtree is so cheap that caching provides no measurable gain
   - Would add dependency for no benefit

3. **distanceMin CORRECT**
   - Set to 1 in constants, scaled by minRadius*0.5 in adaptive-physics.ts
   - Properly prevents infinite force for coincident nodes

4. **Charge strength CORRECT**
   - Uses massFactor=(radius/avgRadius)² for size-proportional repulsion
   - Root node correctly excluded (returns 0)
   - Strength of -10 is reasonable for mixed node sizes

### Recommendation
Could change theta from 0.5 to 0.9/1.0 for marginal improvement but perf gain imperceptible
at 30 nodes. Current implementation is acceptable - no action required.

### References consulted
- https://d3js.org/d3-force/many-body
- https://jheer.github.io/barnes-hut/
- https://github.com/twosixlabs/d3-force-reuse

### Notes
- Pre-existing typecheck errors unchanged
- Lint passes
