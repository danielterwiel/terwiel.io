{
  "title": "StackCloud Performance Investigation & Optimization",
  "description": "Systematic performance audit of StackCloud D3 force simulation, React rendering, and View Transitions interactions",
  "version": "1.0.0",
  "stories": [
    {
      "category": "investigation",
      "id": "inv-01",
      "description": "Investigate stack-node.tsx performance: CSS transitions, drop-shadow rendering, memoization effectiveness, willChange usage, paint containment",
      "steps_to_verify": [
        "Read stack-node.tsx and analyze memoization comparison function",
        "Check if CSS drop-shadow (lines 100-110) is optimal vs SVG filters",
        "Verify willChange usage pattern (line 194) - only set when animating?",
        "Confirm paint containment (line 199) is properly scoped for SVG",
        "Analyze transition string construction (lines 167-170) - should be memoized?",
        "Check if inline style objects are recreated on every render",
        "Search D3/web for best practices on SVG node rendering performance"
      ],
      "passes": true,
      "findings": [
        "CSS drop-shadow is optimal - GPU accelerated, 40-60% faster than SVG filters",
        "willChange correctly conditional - only when isSelected/isHighlighted",
        "Memoization comparison function is thorough and correct",
        "FIXED: Inline style object recreated on every render - now memoized via useMemo (fix-04)",
        "FIXED: transitionStyle string computed every render - now memoized (fix-04)",
        "FIXED: getDropShadow() called every render - now memoized as dropShadow (fix-04)",
        "WARN: contain:paint may not work on SVG elements - needs verification"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-02",
      "description": "Investigate use-stack-simulation.ts: RAF throttling, tick batching, position cache effectiveness, simulation reheat patterns",
      "steps_to_verify": [
        "Read use-stack-simulation.ts handleTick implementation",
        "Verify RAF throttling (16ms) is optimal - should it be adaptive?",
        "Analyze TICKS_PER_FRAME=2 logic - is this backed by D3 research?",
        "Check position cache threshold (0.5px) - is this optimal?",
        "Review simulation.alphaTarget patterns - are they causing unnecessary reheats?",
        "Analyze updateNodeScaleFactors - is collide.initialize() expensive?",
        "Search D3 docs for forceSimulation tick optimization best practices"
      ],
      "passes": true,
      "findings": [
        "RAF throttling CORRECT: Double throttle (RAF + 16ms check) is appropriate; D3 timer already uses RAF internally so 16ms check is redundant but harmless",
        "TICKS_PER_FRAME=2 CORRECT: Backed by research - 'force layout is pure math' so multiple ticks per frame is valid; 2 is conservative for ~30 nodes",
        "Position cache 0.5px CORRECT: Sub-pixel changes imperceptible; cache properly includes scaleFactor for invalidation",
        "alphaTarget patterns CORRECT: Values kept low (0.03-0.1) to prevent jitter; setTimeout properly resets to 0; isSettlingRef properly tracks state",
        "collide.initialize() ACCEPTABLE: O(n) operation but only called when scales actually change (hasChanges guard); cheap for ~30 nodes",
        "NO BUGS FOUND: Implementation follows D3 best practices well; no adaptive throttle needed for small node count"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-03",
      "description": "Investigate all stack-cloud utils: adaptive-physics.ts, create-forces.ts, boundary-force.ts, root-exclusion-force.ts, mass-dampen-force.ts, calculate-stack-size.ts, performance-utils.ts, selection-index.ts, seed-position.ts, distribute-nodes-in-segment.ts, calculate-domain-angles.ts, convert-arc-angle.ts, calculate-base-radius.ts",
      "steps_to_verify": [
        "Read adaptive-physics.ts - check if viewport metrics are computed too often",
        "Read create-forces.ts - are forces recreated unnecessarily in updateSimulationForces?",
        "Check if forceX/forceY/charge are recreated vs updated in-place",
        "Read boundary-force.ts - O(n) loop with conditions - any optimizations?",
        "Read root-exclusion-force.ts - Math.sqrt on every tick for every node?",
        "Read mass-dampen-force.ts - is the curried function pattern efficient?",
        "Read calculate-stack-size.ts - date parsing on every calculation?",
        "Verify selection-index.ts O(1) claims - is it truly O(1)?",
        "Check if any utils do expensive work that should be memoized",
        "Search for D3 custom force performance patterns"
      ],
      "passes": true,
      "findings": [
        "adaptive-physics.ts CORRECT: All functions pure, O(1) or O(n), only called on init/resize (debounced)",
        "create-forces.ts ACCEPTABLE: updateSimulationForces recreates forceX/forceY/charge, but D3 forces are lightweight. Only on resize (100ms debounce)",
        "boundary-force.ts CORRECT: O(n) per tick but simple arithmetic. Has .update() for in-place updates",
        "root-exclusion-force.ts CORRECT: Math.sqrt per node per tick is standard D3 pattern. Has .update() method",
        "FIXED: mass-dampen-force.ts - incorrect D3 pattern fixed in fix-01",
        "calculate-stack-size.ts ACCEPTABLE: parseISO per project but memoized via useMemo in stack-cloud-content.tsx",
        "FIXED: calculate-base-radius.ts - redundant work fixed in fix-03, now accepts pre-computed params",
        "selection-index.ts CORRECT: O(1) lookups via Set.has() and Map.get(). buildSelectionIndex O(n) but once",
        "performance-utils.ts CORRECT: Position cache with 0.5px threshold is efficient",
        "seed-position.ts, distribute-nodes-in-segment.ts, calculate-domain-angles.ts, convert-arc-angle.ts: All CORRECT - pure O(1) math"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-04",
      "description": "Investigate forceManyBody theta parameter and Barnes-Hut optimization",
      "steps_to_verify": [
        "Read D3 forceManyBody documentation on theta parameter",
        "Current theta=0.5 - research shows 0.9 is default, 1.0 often better for perf",
        "Analyze if d3-force-reuse library would benefit this use case (~30 nodes)",
        "Check if distanceMin is set correctly to prevent infinite force",
        "Review charge strength calculation with mass factor",
        "Search for Barnes-Hut theta recommendations for small node counts"
      ],
      "passes": true,
      "findings": [
        "theta=0.5 SUBOPTIMAL BUT HARMLESS: D3 default is 0.9, research recommends 1.0 for best accuracy/perf balance. Per Barnes-Hut research, theta=0.5 does NOT outperform naive O(n²) until ~6000 nodes",
        "FOR ~30 NODES: Barnes-Hut provides NO benefit. Quadtree overhead may actually slow things down. Current theta=0.5 has more overhead than naive but impact is negligible at this scale",
        "d3-force-reuse NOT BENEFICIAL: Library caches quadtree and recalcs every 13 ticks. At ~30 nodes, quadtree is so cheap that caching provides no gain",
        "distanceMin CORRECT: Set to 1, scaled by minRadius*0.5 in adaptive-physics.ts to prevent infinite force for coincident nodes",
        "charge strength CORRECT: Uses massFactor=(radius/avgRadius)² for size-proportional repulsion. Root node correctly excluded (returns 0)",
        "RECOMMENDATION: Could change theta from 0.5 to 0.9 (D3 default) or 1.0 but perf gain is imperceptible at 30 nodes. No action needed."
      ]
    },
    {
      "category": "investigation",
      "id": "inv-05",
      "description": "Investigate forceCollide iterations and collision detection",
      "steps_to_verify": [
        "Current COLLISION_ITERATIONS=12 - D3 default is 1",
        "Research if 12 iterations is excessive for ~30 nodes",
        "Check if iteration count impacts jitter or is overkill",
        "Analyze collision radius function - is it recalculated every tick?",
        "Verify COLLISION_STRENGTH=1.0 is optimal",
        "Search D3 docs for forceCollide performance with varying sizes"
      ],
      "passes": true,
      "findings": [
        "COLLISION_ITERATIONS=12 EXCESSIVE BUT HARMLESS: D3 default is 1, official example (200 nodes) uses 3, NebulaGraph uses 2. At ~30 nodes, 12 iterations is overkill but perf impact is negligible",
        "Iteration cost is O(n) per iteration via quadtree. With n=30, even 12 iterations completes in microseconds",
        "COLLISION_STRENGTH=1.0 CORRECT: This is D3 default, provides maximum rigidity. Combined with high iterations, prevents any overlap",
        "Collision radius function CACHED: D3 caches radius accessor result during initialize(). Re-cached when collide.initialize() called on scale factor changes",
        "Varying node sizes CORRECTLY HANDLED: radius=(d.radius * scaleFactor + collisionPadding) properly accounts for size differences",
        "RECOMMENDATION: Could reduce COLLISION_ITERATIONS from 12 to 3-4 for micro-optimization, but current value works well for mixed-size nodes without jitter. No action required."
      ]
    },
    {
      "category": "investigation",
      "id": "inv-06",
      "description": "Investigate stack-cloud-content.tsx: useMemo dependencies, useCallback patterns, render loop efficiency",
      "steps_to_verify": [
        "Read stack-cloud-content.tsx and count useMemo/useCallback usage",
        "Check if scaleFactors useMemo (lines 108-155) has correct dependencies",
        "Analyze stacks.map render loop - repeated getSearchQuery/getSearchDomain calls?",
        "Verify createStackNodeRefCallback and createStackMouseEnterCallback are stable",
        "Check if selectionIndex.isStackInDomain calls are truly O(1)",
        "Review useDeferredValue usage - is it helping or hurting?",
        "Analyze roving tabindex calculation per render"
      ],
      "passes": true,
      "findings": [
        "scaleFactors useMemo CORRECT: dependencies [stacks, searchParams, selectionIndex], uses O(1) selectionIndex lookups",
        "FIXED: stacks.map() render loop - function calls hoisted outside loop in fix-02",
        "createStackNodeRefCallback CORRECT: Properly memoized factory function",
        "createStackMouseEnterCallback CONCERN: Returns new closure per stack per render (line 399) - could cause unnecessary child re-renders if React.memo used",
        "selectionIndex.isStackInDomain CORRECT: O(1) via Map.get().has()",
        "useDeferredValue CORRECT: Properly defers searchParams to prioritize animations",
        "FIXED: rovingTabindex.getTabIndex() - now uses O(1) Map lookup, fixed in fix-02"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-07",
      "description": "Investigate root-node-chart.tsx: D3 transitions, event handler setup, SVG filter performance",
      "steps_to_verify": [
        "Read root-node-chart.tsx - very long file, many useEffects",
        "Check if SVG glow filter (feGaussianBlur) impacts performance",
        "Analyze D3 transition tween functions - are they efficient?",
        "Review handleHoverStart/handleHoverEnd - DOM selections on every call?",
        "Check if d3.select() is called too frequently",
        "Verify interrupt() usage - is it causing transition conflicts?",
        "Analyze event handler registration - is it done optimally?"
      ],
      "passes": true,
      "findings": [
        "SVG glow filter (feGaussianBlur stdDeviation=2) ACCEPTABLE: Low blur value, only ~6 segments, applied conditionally. Per Chrome docs, SVG-on-SVG filters use CPU path but impact negligible at this scale",
        "D3 transition tween functions CORRECT: Batch DOM reads before writes (lines 201-214), use D3 interpolators, update datum state at t=1. Follows D3 best practice of tween initialization batching",
        "d3.select() calls in event handlers ACCEPTABLE: Called once per hover/focus event, not per frame. Selection is cached within tween closure. D3 recommends caching selections but per-event cost is trivial",
        "interrupt() usage CORRECT: Immediately interrupts ongoing transitions before starting new ones (lines 222-223, 609-610). This is D3 best practice for responsive feel - prevents animation queue buildup",
        "Event handler registration CORRECT: Done once in setupHoverInteractions() after initial render/animation, not on every render. Handlers use D3's .on() method which efficiently attaches to selections",
        "CONCERN: handleHoverStart/handleHoverEnd create new d3.select() calls (lines 583-607, 690-724) but these are per-event, not per-frame. Caching the visualsLayer selection earlier would be micro-optimization",
        "arcs.findIndex() in focus handler (line 966) O(n) per focus event: Trivial for ~6 segments, called only on keyboard focus, not on hover",
        "Random ID generation (lines 407, 447) ACCEPTABLE: Only called once per mount, not per render",
        "NO ACTIONABLE BUGS FOUND: Code follows D3 best practices. Some micro-optimizations possible but negligible impact at current scale"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-08",
      "description": "Investigate projects.tsx View Transitions: flushSync usage, transition timing, concurrent transition handling",
      "steps_to_verify": [
        "Read projects.tsx View Transition implementation",
        "Check flushSync usage - is it causing layout thrashing?",
        "Analyze ongoingTransitionRef.current.skipTransition() pattern",
        "Verify diffProjectStates is efficient",
        "Check if filterCache is working correctly",
        "Review useScrollDelegation hook impact",
        "Search for View Transitions + React best practices 2025"
      ],
      "passes": true,
      "findings": [
        "CRITICAL BUG FOUND: flushSync + startViewTransition was BLOCKING React's concurrent rendering, causing 3-6 second lag on StackNode clicks!",
        "Root cause: flushSync opts out of React's batching. When StackNode.handleClick uses startTransition(), the flushSync in projects.tsx interrupts it",
        "Per React docs: 'If a flushSync happens in the middle of a view transition sequence, React will skip the Transition'",
        "FIXED in fix-05: Removed manual startViewTransition + flushSync. React's built-in ViewTransition (via Next.js config) handles animations",
        "FIXED in fix-05: O(n²) isVisible prop now uses Set for O(1) lookup",
        "FIXED in fix-05: Inline callbacks in stack-cloud-content.tsx now memoized via Map to prevent recreation per render",
        "skipTransition() pattern was OVER-ENGINEERED: No longer needed since we don't manually manage transitions",
        "diffProjectStates EFFICIENT: Uses Set for O(1) lookups, O(n) overall complexity for comparing filtered lists",
        "filterCache CORRECT: Simple LRU with 50 entry max, prevents redundant filtering operations",
        "CODE SMELL: Safari detection duplicated between projects.tsx and use-scroll-delegation.ts. Should extract to shared utility",
        "RESULT: Subsequent StackNode clicks now 270-350ms (down from 3-6 seconds). First click still slow due to dev server HMR."
      ]
    },
    {
      "category": "investigation",
      "id": "inv-09",
      "description": "Investigate use-dimensions.ts: ResizeObserver efficiency, debounce timing, calculateBaseStackRadius frequency",
      "steps_to_verify": [
        "Read use-dimensions.ts implementation",
        "Check if 100ms debounce is optimal for resize",
        "Analyze calculateBaseStackRadius - is it expensive? Called too often?",
        "Verify visualViewport listener cleanup",
        "Check if dimensions object causes unnecessary re-renders"
      ],
      "passes": true,
      "findings": [
        "100ms debounce OPTIMAL: Standard for resize handlers. Not too fast (janky), not too slow (laggy)",
        "FIXED: calculateBaseStackRadius - redundant work fixed in fix-03, now accepts pre-computed stacks/sizeFactors",
        "visualViewport listener cleanup CORRECT: Properly removes both 'resize' and 'scroll' listeners",
        "FIXED: Debounced callbacks now call .cancel() in cleanup - fixed in fix-03",
        "dimensions object CORRECT: New object created only on actual resize events, not every render"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-10",
      "description": "Profile actual runtime performance: Chrome DevTools Performance tab analysis",
      "steps_to_verify": [
        "Record performance trace during initial load",
        "Record trace during stack node selection/deselection",
        "Record trace during domain segment hover",
        "Record trace during search input typing",
        "Identify long tasks (>50ms) and their sources",
        "Check for forced synchronous layouts",
        "Analyze paint/composite times for SVG elements"
      ],
      "passes": false
    },
    {
      "category": "fix",
      "id": "fix-01",
      "description": "Fix mass-dampen-force.ts incorrect D3 force pattern - force was NO-OP",
      "steps_to_verify": [
        "Force should have .initialize(nodes) method for D3 to pass nodes",
        "Force function should take alpha param directly, not return curried function",
        "Force should have .update(avgRadius) method for efficient updates"
      ],
      "passes": true,
      "findings": [
        "FIXED: Changed function signature from (alpha) => (nodes) => void to (alpha) => void",
        "FIXED: Added .initialize(_nodes) method to receive nodes from D3 simulation",
        "FIXED: Added .update(avgRadius) method for parameter updates",
        "FIXED: Stores nodes in closure variable, accessed during force execution",
        "Force now follows same pattern as boundary-force.ts and root-exclusion-force.ts"
      ]
    },
    {
      "category": "fix",
      "id": "fix-02",
      "description": "Fix O(n²) render loop bugs in stack-cloud-content.tsx and use-roving-tabindex.ts",
      "steps_to_verify": [
        "Hoist getSearchQuery/getSearchFilter/getSearchDomain calls outside stacks.map() loop",
        "Replace items.findIndex() with O(1) Map lookup in getTabIndex()"
      ],
      "passes": true,
      "findings": [
        "FIXED: Hoisted 4 function calls outside render loop using IIFE pattern - now O(1) per render instead of O(4n)",
        "FIXED: Added indexMap useMemo to use-roving-tabindex.ts for O(1) id->index lookup",
        "FIXED: getTabIndex() now uses indexMap.get() instead of items.findIndex() - O(1) instead of O(n)",
        "Overall complexity reduced from O(n²) to O(n) per render"
      ]
    },
    {
      "category": "fix",
      "id": "fix-03",
      "description": "Fix calculate-base-radius.ts redundant work and use-dimensions.ts debounce cleanup",
      "steps_to_verify": [
        "calculateBaseStackRadius should accept pre-computed stacks/sizeFactors as parameters",
        "useDimensions should pass stacks/sizeFactors from upstream memoized values",
        "Debounced callbacks should call .cancel() in cleanup to prevent state updates after unmount"
      ],
      "passes": true,
      "findings": [
        "FIXED: calculateBaseStackRadius now accepts stacks and sizeFactors as parameters instead of recomputing",
        "FIXED: useDimensions now takes stacks and sizeFactors as parameters, passed from stack-cloud-content.tsx",
        "FIXED: Both debounced callbacks (ResizeObserver and visualViewport) now call .cancel() in cleanup",
        "Eliminates O(projects×stacks) work + date parsing on every viewport resize"
      ]
    },
    {
      "category": "fix",
      "id": "fix-04",
      "description": "Fix stack-node.tsx inline style object recreation on every render",
      "steps_to_verify": [
        "Memoize getDropShadow() result to avoid recalculation on every render",
        "Memoize transitionStyle string to avoid recreation on every render",
        "Memoize the entire style object to prevent new object on every render"
      ],
      "passes": true,
      "findings": [
        "FIXED: dropShadow now useMemo with deps [a11y.shouldShowGlow, state, borderColor]",
        "FIXED: transitionStyle now useMemo with deps [transitionDuration]",
        "FIXED: nodeStyle object now useMemo with deps [dropShadow, transitionStyle, isSelected, isHighlighted]",
        "Prevents ~30 style object recreations per render for memoized StackNode components"
      ]
    },
    {
      "category": "fix",
      "id": "fix-05",
      "description": "Fix StackNode click lag by removing flushSync + startViewTransition anti-pattern",
      "steps_to_verify": [
        "Remove manual document.startViewTransition() calls in projects.tsx",
        "Remove flushSync import and usage - it blocks React's concurrent rendering",
        "Let React's built-in ViewTransition (via Next.js experimental flag) handle animations",
        "Use Set for O(1) isVisible lookup instead of O(n) filtered.some()",
        "Memoize inline callbacks in stack-cloud-content.tsx render loop"
      ],
      "passes": true,
      "findings": [
        "FIXED: Removed flushSync import and all usage from projects.tsx",
        "FIXED: Replaced manual startViewTransition() with startTransition() for non-blocking updates",
        "FIXED: Added CSS transitions to .project-item class for smooth enter/exit animations",
        "FIXED: Project component now applies animation classes (project-from-bottom, project-slide-out) based on projectState",
        "FIXED: O(n²) isVisible prop now uses filteredIdSet.has() for O(1) lookup",
        "FIXED: Created memoized callback Maps (mouseEnterCallbacks, focusCallbacks, combinedNodeRefCallbacks) in stack-cloud-content.tsx",
        "FIXED: Render loop now uses stable callback references from Maps instead of inline functions",
        "RESULT: Subsequent StackNode clicks improved from 3-6 seconds to ~580ms with CSS animations working"
      ]
    }
  ],
  "references": {
    "d3_force_docs": "https://d3js.org/d3-force/simulation",
    "d3_many_body": "https://d3js.org/d3-force/many-body",
    "d3_collide": "https://d3js.org/d3-force/collide",
    "d3_force_reuse": "https://github.com/twosixlabs/d3-force-reuse",
    "barnes_hut": "https://jheer.github.io/barnes-hut/",
    "view_transitions": "https://developer.chrome.com/docs/web-platform/view-transitions",
    "react_view_transition": "https://react.dev/reference/react/ViewTransition"
  },
  "notes": [
    "Current node count is ~30 stacks - relatively small for D3 force simulation",
    "d3-force-reuse may provide 10-90% speedup by reusing quadtree (recalc every 13 ticks)",
    "theta parameter at 0.5 may be too conservative - default is 0.9, 1.0 often works",
    "COLLISION_ITERATIONS=12 is very high - default is 1, 2-4 common for rigidity",
    "View Transitions with flushSync can cause layout thrashing if not careful",
    "willChange should only be set during animations to avoid memory pressure"
  ]
}
