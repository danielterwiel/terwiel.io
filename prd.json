{
  "title": "StackCloud Performance Investigation & Optimization",
  "description": "Systematic performance audit of StackCloud D3 force simulation, React rendering, and View Transitions interactions",
  "version": "1.0.0",
  "stories": [
    {
      "category": "investigation",
      "id": "inv-01",
      "description": "Investigate stack-node.tsx performance: CSS transitions, drop-shadow rendering, memoization effectiveness, willChange usage, paint containment",
      "steps_to_verify": [
        "Read stack-node.tsx and analyze memoization comparison function",
        "Check if CSS drop-shadow (lines 100-110) is optimal vs SVG filters",
        "Verify willChange usage pattern (line 194) - only set when animating?",
        "Confirm paint containment (line 199) is properly scoped for SVG",
        "Analyze transition string construction (lines 167-170) - should be memoized?",
        "Check if inline style objects are recreated on every render",
        "Search D3/web for best practices on SVG node rendering performance"
      ],
      "passes": true,
      "findings": [
        "CSS drop-shadow is optimal - GPU accelerated, 40-60% faster than SVG filters",
        "willChange correctly conditional - only when isSelected/isHighlighted",
        "Memoization comparison function is thorough and correct",
        "BUG: Inline style object recreated on every render (lines 189-200)",
        "BUG: transitionStyle string computed every render, should be memoized",
        "BUG: getDropShadow() called every render via inline style",
        "WARN: contain:paint may not work on SVG elements - needs verification"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-02",
      "description": "Investigate use-stack-simulation.ts: RAF throttling, tick batching, position cache effectiveness, simulation reheat patterns",
      "steps_to_verify": [
        "Read use-stack-simulation.ts handleTick implementation",
        "Verify RAF throttling (16ms) is optimal - should it be adaptive?",
        "Analyze TICKS_PER_FRAME=2 logic - is this backed by D3 research?",
        "Check position cache threshold (0.5px) - is this optimal?",
        "Review simulation.alphaTarget patterns - are they causing unnecessary reheats?",
        "Analyze updateNodeScaleFactors - is collide.initialize() expensive?",
        "Search D3 docs for forceSimulation tick optimization best practices"
      ],
      "passes": true,
      "findings": [
        "RAF throttling CORRECT: Double throttle (RAF + 16ms check) is appropriate; D3 timer already uses RAF internally so 16ms check is redundant but harmless",
        "TICKS_PER_FRAME=2 CORRECT: Backed by research - 'force layout is pure math' so multiple ticks per frame is valid; 2 is conservative for ~30 nodes",
        "Position cache 0.5px CORRECT: Sub-pixel changes imperceptible; cache properly includes scaleFactor for invalidation",
        "alphaTarget patterns CORRECT: Values kept low (0.03-0.1) to prevent jitter; setTimeout properly resets to 0; isSettlingRef properly tracks state",
        "collide.initialize() ACCEPTABLE: O(n) operation but only called when scales actually change (hasChanges guard); cheap for ~30 nodes",
        "NO BUGS FOUND: Implementation follows D3 best practices well; no adaptive throttle needed for small node count"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-03",
      "description": "Investigate all stack-cloud utils: adaptive-physics.ts, create-forces.ts, boundary-force.ts, root-exclusion-force.ts, mass-dampen-force.ts, calculate-stack-size.ts, performance-utils.ts, selection-index.ts, seed-position.ts, distribute-nodes-in-segment.ts, calculate-domain-angles.ts, convert-arc-angle.ts, calculate-base-radius.ts",
      "steps_to_verify": [
        "Read adaptive-physics.ts - check if viewport metrics are computed too often",
        "Read create-forces.ts - are forces recreated unnecessarily in updateSimulationForces?",
        "Check if forceX/forceY/charge are recreated vs updated in-place",
        "Read boundary-force.ts - O(n) loop with conditions - any optimizations?",
        "Read root-exclusion-force.ts - Math.sqrt on every tick for every node?",
        "Read mass-dampen-force.ts - is the curried function pattern efficient?",
        "Read calculate-stack-size.ts - date parsing on every calculation?",
        "Verify selection-index.ts O(1) claims - is it truly O(1)?",
        "Check if any utils do expensive work that should be memoized",
        "Search for D3 custom force performance patterns"
      ],
      "passes": false,
      "findings": [
        "adaptive-physics.ts CORRECT: All functions pure, O(1) or O(n), only called on init/resize (debounced)",
        "create-forces.ts ACCEPTABLE: updateSimulationForces recreates forceX/forceY/charge, but D3 forces are lightweight. Only on resize (100ms debounce)",
        "boundary-force.ts CORRECT: O(n) per tick but simple arithmetic. Has .update() for in-place updates",
        "root-exclusion-force.ts CORRECT: Math.sqrt per node per tick is standard D3 pattern. Has .update() method",
        "BUG: mass-dampen-force.ts INCORRECT PATTERN - Returns force(alpha)->(nodes)->void but D3 expects force(alpha)->void with nodes via .initialize(). Force is NO-OP",
        "calculate-stack-size.ts ACCEPTABLE: parseISO per project but memoized via useMemo in stack-cloud-content.tsx",
        "BUG: calculate-base-radius.ts REDUNDANT WORK - Calls extractUniqueStacks() and calculateStackSizeFactors() on every resize. Already memoized upstream",
        "selection-index.ts CORRECT: O(1) lookups via Set.has() and Map.get(). buildSelectionIndex O(n) but once",
        "performance-utils.ts CORRECT: Position cache with 0.5px threshold is efficient",
        "seed-position.ts, distribute-nodes-in-segment.ts, calculate-domain-angles.ts, convert-arc-angle.ts: All CORRECT - pure O(1) math"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-04",
      "description": "Investigate forceManyBody theta parameter and Barnes-Hut optimization",
      "steps_to_verify": [
        "Read D3 forceManyBody documentation on theta parameter",
        "Current theta=0.5 - research shows 0.9 is default, 1.0 often better for perf",
        "Analyze if d3-force-reuse library would benefit this use case (~30 nodes)",
        "Check if distanceMin is set correctly to prevent infinite force",
        "Review charge strength calculation with mass factor",
        "Search for Barnes-Hut theta recommendations for small node counts"
      ],
      "passes": true,
      "findings": [
        "theta=0.5 SUBOPTIMAL BUT HARMLESS: D3 default is 0.9, research recommends 1.0 for best accuracy/perf balance. Per Barnes-Hut research, theta=0.5 does NOT outperform naive O(n²) until ~6000 nodes",
        "FOR ~30 NODES: Barnes-Hut provides NO benefit. Quadtree overhead may actually slow things down. Current theta=0.5 has more overhead than naive but impact is negligible at this scale",
        "d3-force-reuse NOT BENEFICIAL: Library caches quadtree and recalcs every 13 ticks. At ~30 nodes, quadtree is so cheap that caching provides no gain",
        "distanceMin CORRECT: Set to 1, scaled by minRadius*0.5 in adaptive-physics.ts to prevent infinite force for coincident nodes",
        "charge strength CORRECT: Uses massFactor=(radius/avgRadius)² for size-proportional repulsion. Root node correctly excluded (returns 0)",
        "RECOMMENDATION: Could change theta from 0.5 to 0.9 (D3 default) or 1.0 but perf gain is imperceptible at 30 nodes. No action needed."
      ]
    },
    {
      "category": "investigation",
      "id": "inv-05",
      "description": "Investigate forceCollide iterations and collision detection",
      "steps_to_verify": [
        "Current COLLISION_ITERATIONS=12 - D3 default is 1",
        "Research if 12 iterations is excessive for ~30 nodes",
        "Check if iteration count impacts jitter or is overkill",
        "Analyze collision radius function - is it recalculated every tick?",
        "Verify COLLISION_STRENGTH=1.0 is optimal",
        "Search D3 docs for forceCollide performance with varying sizes"
      ],
      "passes": true,
      "findings": [
        "COLLISION_ITERATIONS=12 EXCESSIVE BUT HARMLESS: D3 default is 1, official example (200 nodes) uses 3, NebulaGraph uses 2. At ~30 nodes, 12 iterations is overkill but perf impact is negligible",
        "Iteration cost is O(n) per iteration via quadtree. With n=30, even 12 iterations completes in microseconds",
        "COLLISION_STRENGTH=1.0 CORRECT: This is D3 default, provides maximum rigidity. Combined with high iterations, prevents any overlap",
        "Collision radius function CACHED: D3 caches radius accessor result during initialize(). Re-cached when collide.initialize() called on scale factor changes",
        "Varying node sizes CORRECTLY HANDLED: radius=(d.radius * scaleFactor + collisionPadding) properly accounts for size differences",
        "RECOMMENDATION: Could reduce COLLISION_ITERATIONS from 12 to 3-4 for micro-optimization, but current value works well for mixed-size nodes without jitter. No action required."
      ]
    },
    {
      "category": "investigation",
      "id": "inv-06",
      "description": "Investigate stack-cloud-content.tsx: useMemo dependencies, useCallback patterns, render loop efficiency",
      "steps_to_verify": [
        "Read stack-cloud-content.tsx and count useMemo/useCallback usage",
        "Check if scaleFactors useMemo (lines 108-155) has correct dependencies",
        "Analyze stacks.map render loop - repeated getSearchQuery/getSearchDomain calls?",
        "Verify createStackNodeRefCallback and createStackMouseEnterCallback are stable",
        "Check if selectionIndex.isStackInDomain calls are truly O(1)",
        "Review useDeferredValue usage - is it helping or hurting?",
        "Analyze roving tabindex calculation per render"
      ],
      "passes": false,
      "findings": [
        "scaleFactors useMemo CORRECT: dependencies [stacks, searchParams, selectionIndex], uses O(1) selectionIndex lookups",
        "BUG: stacks.map() render loop (lines 339-404) calls getSearchQuery(), getSearchFilter(), getSearchDomain() INSIDE the loop - 4 function calls × 30 stacks = 120 calls/render that should be computed once outside",
        "createStackNodeRefCallback CORRECT: Properly memoized factory function",
        "createStackMouseEnterCallback CONCERN: Returns new closure per stack per render (line 399) - could cause unnecessary child re-renders if React.memo used",
        "selectionIndex.isStackInDomain CORRECT: O(1) via Map.get().has()",
        "useDeferredValue CORRECT: Properly defers searchParams to prioritize animations",
        "BUG: rovingTabindex.getTabIndex() uses items.findIndex() which is O(n), called 30x per render = O(n²)"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-07",
      "description": "Investigate root-node-chart.tsx: D3 transitions, event handler setup, SVG filter performance",
      "steps_to_verify": [
        "Read root-node-chart.tsx - very long file, many useEffects",
        "Check if SVG glow filter (feGaussianBlur) impacts performance",
        "Analyze D3 transition tween functions - are they efficient?",
        "Review handleHoverStart/handleHoverEnd - DOM selections on every call?",
        "Check if d3.select() is called too frequently",
        "Verify interrupt() usage - is it causing transition conflicts?",
        "Analyze event handler registration - is it done optimally?"
      ],
      "passes": false
    },
    {
      "category": "investigation",
      "id": "inv-08",
      "description": "Investigate projects.tsx View Transitions: flushSync usage, transition timing, concurrent transition handling",
      "steps_to_verify": [
        "Read projects.tsx View Transition implementation",
        "Check flushSync usage - is it causing layout thrashing?",
        "Analyze ongoingTransitionRef.current.skipTransition() pattern",
        "Verify diffProjectStates is efficient",
        "Check if filterCache is working correctly",
        "Review useScrollDelegation hook impact",
        "Search for View Transitions + React best practices 2025"
      ],
      "passes": false
    },
    {
      "category": "investigation",
      "id": "inv-09",
      "description": "Investigate use-dimensions.ts: ResizeObserver efficiency, debounce timing, calculateBaseStackRadius frequency",
      "steps_to_verify": [
        "Read use-dimensions.ts implementation",
        "Check if 100ms debounce is optimal for resize",
        "Analyze calculateBaseStackRadius - is it expensive? Called too often?",
        "Verify visualViewport listener cleanup",
        "Check if dimensions object causes unnecessary re-renders"
      ],
      "passes": false
    },
    {
      "category": "investigation",
      "id": "inv-10",
      "description": "Profile actual runtime performance: Chrome DevTools Performance tab analysis",
      "steps_to_verify": [
        "Record performance trace during initial load",
        "Record trace during stack node selection/deselection",
        "Record trace during domain segment hover",
        "Record trace during search input typing",
        "Identify long tasks (>50ms) and their sources",
        "Check for forced synchronous layouts",
        "Analyze paint/composite times for SVG elements"
      ],
      "passes": false
    },
    {
      "category": "bug",
      "id": "bug-01",
      "description": "PLACEHOLDER: Bugs discovered during investigation will be added here",
      "steps_to_verify": ["Placeholder - will be filled after investigation"],
      "passes": false
    }
  ],
  "references": {
    "d3_force_docs": "https://d3js.org/d3-force/simulation",
    "d3_many_body": "https://d3js.org/d3-force/many-body",
    "d3_collide": "https://d3js.org/d3-force/collide",
    "d3_force_reuse": "https://github.com/twosixlabs/d3-force-reuse",
    "barnes_hut": "https://jheer.github.io/barnes-hut/",
    "view_transitions": "https://developer.chrome.com/docs/web-platform/view-transitions",
    "react_view_transition": "https://react.dev/reference/react/ViewTransition"
  },
  "notes": [
    "Current node count is ~30 stacks - relatively small for D3 force simulation",
    "d3-force-reuse may provide 10-90% speedup by reusing quadtree (recalc every 13 ticks)",
    "theta parameter at 0.5 may be too conservative - default is 0.9, 1.0 often works",
    "COLLISION_ITERATIONS=12 is very high - default is 1, 2-4 common for rigidity",
    "View Transitions with flushSync can cause layout thrashing if not careful",
    "willChange should only be set during animations to avoid memory pressure"
  ]
}
