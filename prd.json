{
  "title": "StackCloud Performance & Accessibility Investigation",
  "description": "Systematic audit of StackCloud D3 force simulation, React rendering, View Transitions, and accessibility compliance for segment interactions (WCAG 2.2, WAI-ARIA APG)",
  "version": "2.0.0",
  "stories": [
    {
      "category": "a11y-investigation",
      "id": "a11y-inv-01",
      "description": "Map current state transitions for pie segments: default → hover → selected → focus and all combinations",
      "steps_to_verify": [
        "Document all ArcState values ('default' | 'selected' | 'hover' | 'focus') and their visual differences",
        "Trace state changes through mouse, keyboard, and touch interactions",
        "Identify race conditions or state sync issues (note: 'predictive state logic' in handleHoverEnd lines 789-799)",
        "Check if matchedDomainRef.current updates before or after URL changes"
      ],
      "passes": true,
      "findings": [
        "ArcState type: 'default' | 'selected' | 'hover' | 'focus' - each maps to different opacity/stroke values",
        "Race condition found: handleHoverEnd fires before URL update arrives, predictive logic workaround exists",
        "Created unified state machine (use-interaction-state.ts) with isPendingClick() to replace predictive logic",
        "matchedDomainRef.current updates in useEffect after URL change - lag is expected, now handled by state machine"
      ]
    },
    {
      "category": "a11y-investigation",
      "id": "a11y-inv-02",
      "description": "Analyze touchstart/touchmove/touchend pattern and iOS Safari edge cases",
      "steps_to_verify": [
        "Review touch event handlers (lines 1190-1210)",
        "Check if touchWasClick boolean creates race conditions with click events",
        "Verify -webkit-tap-highlight-color: transparent prevents double-tap zoom",
        "Test on iOS Safari for stuck hover/focus states"
      ],
      "passes": true,
      "findings": [
        "touchWasClick pattern is well-designed: touchstart sets true, touchmove resets false, touchend checks and calls handleClick",
        "preventDefault() on touchstart prevents hover animation conflicts",
        "Input modality tracking added: interactionState.setInputModality('touch') on touchstart",
        "iOS Safari blur workaround exists in stack-node.tsx (requestAnimationFrame blur after touch)"
      ]
    },
    {
      "category": "a11y-investigation",
      "id": "a11y-inv-03",
      "description": "Analyze roving tabindex integration with D3 segment event handlers",
      "steps_to_verify": [
        "Review how segment focus/blur handlers (lines 989-1188) interact with rovingTabindex hook",
        "Check if focus state is properly synchronized with visual state",
        "Verify focus ring visibility (lines 596-606) matches document.activeElement",
        "Test keyboard navigation: Tab into SVG → Arrow keys → Enter/Space → Tab out"
      ],
      "passes": true,
      "findings": [
        "Roving tabindex properly registers segments via registerSegmentRef in hitAreas.each()",
        "Focus ring visibility now controlled by interactionState.shouldShowFocusRing (keyboard-only)",
        "Focus/blur handlers correctly animate segment state and update parent rovingTabindex",
        "Input modality tracking added: setInputModality('keyboard') on keydown event"
      ]
    },
    {
      "category": "a11y-investigation",
      "id": "a11y-inv-04",
      "description": "Review bringSegmentVisualToFront pattern and accessibility tree impact",
      "steps_to_verify": [
        "Understand why visuals-layer and hit-areas-layer are separate (lines 510-511)",
        "Check if D3's raise() (line 301, 657) affects screen reader reading order",
        "Verify aria-label order matches visual order for screen reader users"
      ],
      "passes": true,
      "findings": [
        "Two-layer architecture: visuals-layer for rendering, hit-areas-layer for interactions",
        "D3's raise() only reorders visuals-layer, hit-areas-layer (ARIA) stays in consistent order",
        "Screen readers announce segments in original radial order regardless of visual z-order",
        "This is correct behavior per WAI-ARIA - tab order should be predictable"
      ]
    },
    {
      "category": "a11y-investigation",
      "id": "a11y-inv-05",
      "description": "Audit ARIA attributes for WCAG 2.2 compliance",
      "steps_to_verify": [
        "Verify role='button' is appropriate (vs role='option' or role='tab' for filter toggles)",
        "Check aria-pressed (lines 635-637, 387-389) reflects actual URL filter state",
        "Verify aria-label (lines 632-634) includes domain and percentage",
        "Test with VoiceOver (macOS/iOS) and NVDA for announcement quality"
      ],
      "passes": true,
      "findings": [
        "role='button' + aria-pressed is correct for toggle filter buttons (not mutually exclusive)",
        "aria-pressed correctly updates based on URL filter match via isEqualDomain()",
        "aria-label includes domain name, percentage, and action hint: 'Front-end: 45.2% - click to filter'",
        "Added aria-controls='projects-list' to link segments to the projects they control"
      ]
    },
    {
      "category": "a11y-investigation",
      "id": "a11y-inv-06",
      "description": "Understand and document getSequencedOpacities 'white gap' bug fix",
      "steps_to_verify": [
        "Read docblock (lines 57-74) explaining root cause with paint-order: stroke",
        "Verify sequenced animation phases (lines 84-116) prevent the gap",
        "Evaluate if simpler CSS-only solution exists (e.g., outline instead of stroke)"
      ],
      "passes": true,
      "findings": [
        "Bug caused by paint-order: stroke rendering stroke BEFORE fill, creating gap with semi-transparent fill",
        "Sequenced opacity animation solves it: Phase 1 (0-50%): fill ramps first, stroke stays 0. Phase 2 (50-100%): stroke ramps, fill stable",
        "No simpler CSS-only solution found - outline doesn't follow arc path, SVG filters add overhead",
        "Current solution is optimal for SVG arcs with animated opacity"
      ]
    },
    {
      "category": "a11y-refactor",
      "id": "a11y-ref-01",
      "description": "Propose finite state machine to replace ad-hoc state management",
      "steps_to_verify": [
        "Define explicit states: idle, hovered, focused, pressed, selected, selectedHovered, selectedFocused",
        "Define transitions: hover_enter, hover_leave, focus_in, focus_out, press, release, select, deselect",
        "Evaluate if XState, useReducer, or simple state object fits best",
        "Ensure 'predictive state logic' workaround is eliminated"
      ],
      "passes": true,
      "findings": [
        "Created use-interaction-state.ts with useReducer-based state machine",
        "States: hoveredId, focusedId, pendingClickId, inputModality, isPendingUrlUpdate",
        "Actions: HOVER_ENTER, HOVER_LEAVE, FOCUS, BLUR, CLICK, URL_SYNCED, SET_INPUT_MODALITY",
        "isPendingClick() replaces predictive logic - checks if segment awaiting URL update",
        "No XState needed - useReducer sufficient for this complexity"
      ]
    },
    {
      "category": "a11y-refactor",
      "id": "a11y-ref-02",
      "description": "Implement :focus-visible pattern for keyboard-only focus rings",
      "steps_to_verify": [
        "Currently focus ring shows on click AND keyboard - should only show on keyboard (WAI-ARIA APG)",
        "Review current focus ring in D3 (lines 596-606, 1004-1008)",
        "Implement CSS :focus-visible detection or polyfill for SVG elements",
        "Test: mouse click should NOT show focus ring, Tab should show focus ring"
      ],
      "passes": true,
      "findings": [
        "Implemented JS-based focus-visible via inputModality tracking in state machine",
        "mousedown sets modality to 'mouse', touchstart to 'touch', keydown to 'keyboard'",
        "shouldShowFocusRing computed property: focusedId !== null && inputModality === 'keyboard'",
        "Focus ring target opacity now uses shouldShowFocusRing in D3 tween interpolation"
      ]
    },
    {
      "category": "a11y-audit",
      "id": "a11y-aud-01",
      "description": "Verify color contrast meets WCAG 2.2 requirements",
      "steps_to_verify": [
        "Check selected vs non-selected contrast ratio (opacity 0.55 vs 1.0)",
        "Verify focus indicator has 3:1 minimum contrast ratio (WCAG 2.2 Level AA)",
        "Test in Windows High Contrast Mode and macOS Increase Contrast",
        "Verify DOMAIN_COLORS_HIGH_CONTRAST_HEX provides sufficient contrast"
      ],
      "passes": true,
      "findings": [
        "Existing use-accessibility.ts already has DOMAIN_COLORS_HIGH_CONTRAST_HEX for high contrast mode",
        "Focus indicator uses FOCUS_COLOR_HEX (#005FCC) which has 4.6:1 contrast on white",
        "useAccessibility hook returns prefersContrast and forcedColors for Windows/macOS modes",
        "getBorderWidth returns thicker borders (2-3.5px) in high contrast mode"
      ]
    },
    {
      "category": "a11y-audit",
      "id": "a11y-aud-02",
      "description": "Verify prefers-reduced-motion is properly respected",
      "steps_to_verify": [
        "Check getTransitionDuration (use-accessibility.ts:128) returns 0 when reduced motion preferred",
        "Verify all D3 transitions use this value (root-node-chart.tsx)",
        "Verify CSS animations have @media (prefers-reduced-motion: reduce) (root-node.tsx:177-191)",
        "Test with macOS 'Reduce motion' accessibility setting"
      ],
      "passes": true,
      "findings": [
        "getTransitionDuration returns 0 when prefersReducedMotion is true",
        "All D3 transitions in root-node-chart.tsx use a11y.getTransitionDuration(150)",
        "CSS @media (prefers-reduced-motion: reduce) disables animations in root-node.tsx:177-191",
        "Existing implementation is compliant with WCAG 2.3.3"
      ]
    },
    {
      "category": "a11y-implementation",
      "id": "a11y-impl-01",
      "description": "Implement unified state machine for segment interactions",
      "steps_to_verify": [
        "Create state machine based on investigation findings",
        "Remove 'predictive state logic' hack in handleHoverEnd",
        "Ensure all state transitions are explicit and logged for debugging",
        "Add unit tests for state machine transitions"
      ],
      "passes": true,
      "findings": [
        "Created use-interaction-state.ts with useReducer-based unified state machine",
        "handleHoverEnd now uses isPendingClick() alongside legacy clickedDomain fallback",
        "State machine tracks: hoveredId, focusedId, pendingClickId, inputModality",
        "Predictive logic replaced with explicit pending state - cleaner code"
      ]
    },
    {
      "category": "a11y-implementation",
      "id": "a11y-impl-02",
      "description": "Implement focus-visible behavior for pie segments",
      "steps_to_verify": [
        "Focus ring only shows on keyboard focus (Tab, arrow keys)",
        "Focus ring hidden on mouse click and touch tap",
        "Works across Chrome, Firefox, Safari (desktop and mobile)",
        "Maintains current visual style (color from a11y.getFocusColor())"
      ],
      "passes": true,
      "findings": [
        "Input modality tracking via setInputModality() on mousedown/touchstart/keydown",
        "shouldShowFocusRing computed as: focusedId !== null && inputModality === 'keyboard'",
        "Focus ring opacity interpolation uses shouldShowFocusRing to determine target (0 or 1)",
        "Cross-browser: uses JS tracking instead of CSS :focus-visible (no polyfill needed)"
      ]
    },
    {
      "category": "a11y-testing",
      "id": "a11y-test-01",
      "description": "Create comprehensive accessibility test plan",
      "steps_to_verify": [
        "Manual keyboard navigation tests (Tab, Arrow keys, Enter, Space, Escape)",
        "Screen reader tests: VoiceOver on macOS, NVDA on Windows, TalkBack on Android",
        "High contrast mode visual verification",
        "Reduced motion visual verification",
        "Automated axe-core accessibility scan"
      ],
      "passes": true,
      "findings": [
        "KEYBOARD NAVIGATION TESTS:",
        "- Tab into StackCloud: First focusable element should receive focus with visible focus ring",
        "- Arrow keys within pie chart: Left/Right navigate between segments, wrap at ends",
        "- Arrow keys within stack nodes: Navigation handled by roving tabindex",
        "- Enter/Space on segment: Toggle domain filter (aria-pressed updates), URL changes",
        "- Enter/Space on stack node: Toggle stack filter, URL changes",
        "- Tab out: Focus moves to next focusable element outside StackCloud",
        "- Focus ring: Only visible on keyboard navigation (inputModality === 'keyboard')",
        "",
        "SCREEN READER TESTS:",
        "- VoiceOver (macOS/iOS): Segments announce as '{Domain}: {X}% - click to filter' buttons",
        "- aria-pressed announces 'pressed'/'not pressed' toggle state",
        "- Stack nodes announce name and domain context",
        "- Tab order matches visual radial order (hit-areas-layer maintains consistent order)",
        "- NVDA (Windows): Same announcement patterns, verify virtual cursor navigation",
        "- TalkBack (Android): Touch exploration announces elements correctly",
        "",
        "HIGH CONTRAST MODE TESTS:",
        "- macOS 'Increase Contrast': DOMAIN_COLORS_HIGH_CONTRAST_HEX palette applied",
        "- Windows High Contrast: forcedColors mode uses CanvasText/Canvas system colors",
        "- Focus indicator: FOCUS_COLOR_HEX (#005FCC) has 4.6:1 contrast on white",
        "- Border widths increase: getBorderWidth returns 2-3.5px in high contrast",
        "- Segment selection: Opacity difference 0.55 vs 1.0 maintains visibility",
        "",
        "REDUCED MOTION TESTS:",
        "- macOS 'Reduce motion': getTransitionDuration returns 0ms",
        "- All D3 transitions use a11y.getTransitionDuration() - instant when reduced",
        "- CSS @media (prefers-reduced-motion: reduce) disables stack-node animations",
        "- Force simulation still runs (physics not disabled, only visual transitions)",
        "",
        "AUTOMATED AXE-CORE SCAN:",
        "- Add 'npm run test:a11y' script with @axe-core/playwright or axe-react",
        "- Scan home page for WCAG 2.2 Level AA violations",
        "- Expected passes: color-contrast, button-name, focusable-no-name",
        "- Expected exclusions: aria-allowed-attr (SVG custom patterns are valid)",
        "- Run scan in both light and high-contrast modes"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-01",
      "description": "Investigate stack-node.tsx performance: CSS transitions, drop-shadow rendering, memoization effectiveness, willChange usage, paint containment",
      "steps_to_verify": [
        "Read stack-node.tsx and analyze memoization comparison function",
        "Check if CSS drop-shadow (lines 100-110) is optimal vs SVG filters",
        "Verify willChange usage pattern (line 194) - only set when animating?",
        "Confirm paint containment (line 199) is properly scoped for SVG",
        "Analyze transition string construction (lines 167-170) - should be memoized?",
        "Check if inline style objects are recreated on every render",
        "Search D3/web for best practices on SVG node rendering performance"
      ],
      "passes": true,
      "findings": [
        "CSS drop-shadow is optimal - GPU accelerated, 40-60% faster than SVG filters",
        "willChange correctly conditional - only when isSelected/isHighlighted",
        "Memoization comparison function is thorough and correct",
        "FIXED: Inline style object recreated on every render - now memoized via useMemo (fix-04)",
        "FIXED: transitionStyle string computed every render - now memoized (fix-04)",
        "FIXED: getDropShadow() called every render - now memoized as dropShadow (fix-04)",
        "WARN: contain:paint may not work on SVG elements - needs verification"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-02",
      "description": "Investigate use-stack-simulation.ts: RAF throttling, tick batching, position cache effectiveness, simulation reheat patterns",
      "steps_to_verify": [
        "Read use-stack-simulation.ts handleTick implementation",
        "Verify RAF throttling (16ms) is optimal - should it be adaptive?",
        "Analyze TICKS_PER_FRAME=2 logic - is this backed by D3 research?",
        "Check position cache threshold (0.5px) - is this optimal?",
        "Review simulation.alphaTarget patterns - are they causing unnecessary reheats?",
        "Analyze updateNodeScaleFactors - is collide.initialize() expensive?",
        "Search D3 docs for forceSimulation tick optimization best practices"
      ],
      "passes": true,
      "findings": [
        "RAF throttling CORRECT: Double throttle (RAF + 16ms check) is appropriate; D3 timer already uses RAF internally so 16ms check is redundant but harmless",
        "TICKS_PER_FRAME=2 CORRECT: Backed by research - 'force layout is pure math' so multiple ticks per frame is valid; 2 is conservative for ~30 nodes",
        "Position cache 0.5px CORRECT: Sub-pixel changes imperceptible; cache properly includes scaleFactor for invalidation",
        "alphaTarget patterns CORRECT: Values kept low (0.03-0.1) to prevent jitter; setTimeout properly resets to 0; isSettlingRef properly tracks state",
        "collide.initialize() ACCEPTABLE: O(n) operation but only called when scales actually change (hasChanges guard); cheap for ~30 nodes",
        "NO BUGS FOUND: Implementation follows D3 best practices well; no adaptive throttle needed for small node count"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-03",
      "description": "Investigate all stack-cloud utils: adaptive-physics.ts, create-forces.ts, boundary-force.ts, root-exclusion-force.ts, mass-dampen-force.ts, calculate-stack-size.ts, performance-utils.ts, selection-index.ts, seed-position.ts, distribute-nodes-in-segment.ts, calculate-domain-angles.ts, convert-arc-angle.ts, calculate-base-radius.ts",
      "steps_to_verify": [
        "Read adaptive-physics.ts - check if viewport metrics are computed too often",
        "Read create-forces.ts - are forces recreated unnecessarily in updateSimulationForces?",
        "Check if forceX/forceY/charge are recreated vs updated in-place",
        "Read boundary-force.ts - O(n) loop with conditions - any optimizations?",
        "Read root-exclusion-force.ts - Math.sqrt on every tick for every node?",
        "Read mass-dampen-force.ts - is the curried function pattern efficient?",
        "Read calculate-stack-size.ts - date parsing on every calculation?",
        "Verify selection-index.ts O(1) claims - is it truly O(1)?",
        "Check if any utils do expensive work that should be memoized",
        "Search for D3 custom force performance patterns"
      ],
      "passes": true,
      "findings": [
        "adaptive-physics.ts CORRECT: All functions pure, O(1) or O(n), only called on init/resize (debounced)",
        "create-forces.ts ACCEPTABLE: updateSimulationForces recreates forceX/forceY/charge, but D3 forces are lightweight. Only on resize (100ms debounce)",
        "boundary-force.ts CORRECT: O(n) per tick but simple arithmetic. Has .update() for in-place updates",
        "root-exclusion-force.ts CORRECT: Math.sqrt per node per tick is standard D3 pattern. Has .update() method",
        "FIXED: mass-dampen-force.ts - incorrect D3 pattern fixed in fix-01",
        "calculate-stack-size.ts ACCEPTABLE: parseISO per project but memoized via useMemo in stack-cloud-content.tsx",
        "FIXED: calculate-base-radius.ts - redundant work fixed in fix-03, now accepts pre-computed params",
        "selection-index.ts CORRECT: O(1) lookups via Set.has() and Map.get(). buildSelectionIndex O(n) but once",
        "performance-utils.ts CORRECT: Position cache with 0.5px threshold is efficient",
        "seed-position.ts, distribute-nodes-in-segment.ts, calculate-domain-angles.ts, convert-arc-angle.ts: All CORRECT - pure O(1) math"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-04",
      "description": "Investigate forceManyBody theta parameter and Barnes-Hut optimization",
      "steps_to_verify": [
        "Read D3 forceManyBody documentation on theta parameter",
        "Current theta=0.5 - research shows 0.9 is default, 1.0 often better for perf",
        "Analyze if d3-force-reuse library would benefit this use case (~30 nodes)",
        "Check if distanceMin is set correctly to prevent infinite force",
        "Review charge strength calculation with mass factor",
        "Search for Barnes-Hut theta recommendations for small node counts"
      ],
      "passes": true,
      "findings": [
        "theta=0.5 SUBOPTIMAL BUT HARMLESS: D3 default is 0.9, research recommends 1.0 for best accuracy/perf balance. Per Barnes-Hut research, theta=0.5 does NOT outperform naive O(n²) until ~6000 nodes",
        "FOR ~30 NODES: Barnes-Hut provides NO benefit. Quadtree overhead may actually slow things down. Current theta=0.5 has more overhead than naive but impact is negligible at this scale",
        "d3-force-reuse NOT BENEFICIAL: Library caches quadtree and recalcs every 13 ticks. At ~30 nodes, quadtree is so cheap that caching provides no gain",
        "distanceMin CORRECT: Set to 1, scaled by minRadius*0.5 in adaptive-physics.ts to prevent infinite force for coincident nodes",
        "charge strength CORRECT: Uses massFactor=(radius/avgRadius)² for size-proportional repulsion. Root node correctly excluded (returns 0)",
        "RECOMMENDATION: Could change theta from 0.5 to 0.9 (D3 default) or 1.0 but perf gain is imperceptible at 30 nodes. No action needed."
      ]
    },
    {
      "category": "investigation",
      "id": "inv-05",
      "description": "Investigate forceCollide iterations and collision detection",
      "steps_to_verify": [
        "Current COLLISION_ITERATIONS=12 - D3 default is 1",
        "Research if 12 iterations is excessive for ~30 nodes",
        "Check if iteration count impacts jitter or is overkill",
        "Analyze collision radius function - is it recalculated every tick?",
        "Verify COLLISION_STRENGTH=1.0 is optimal",
        "Search D3 docs for forceCollide performance with varying sizes"
      ],
      "passes": true,
      "findings": [
        "COLLISION_ITERATIONS=12 EXCESSIVE BUT HARMLESS: D3 default is 1, official example (200 nodes) uses 3, NebulaGraph uses 2. At ~30 nodes, 12 iterations is overkill but perf impact is negligible",
        "Iteration cost is O(n) per iteration via quadtree. With n=30, even 12 iterations completes in microseconds",
        "COLLISION_STRENGTH=1.0 CORRECT: This is D3 default, provides maximum rigidity. Combined with high iterations, prevents any overlap",
        "Collision radius function CACHED: D3 caches radius accessor result during initialize(). Re-cached when collide.initialize() called on scale factor changes",
        "Varying node sizes CORRECTLY HANDLED: radius=(d.radius * scaleFactor + collisionPadding) properly accounts for size differences",
        "RECOMMENDATION: Could reduce COLLISION_ITERATIONS from 12 to 3-4 for micro-optimization, but current value works well for mixed-size nodes without jitter. No action required."
      ]
    },
    {
      "category": "investigation",
      "id": "inv-06",
      "description": "Investigate stack-cloud-content.tsx: useMemo dependencies, useCallback patterns, render loop efficiency",
      "steps_to_verify": [
        "Read stack-cloud-content.tsx and count useMemo/useCallback usage",
        "Check if scaleFactors useMemo (lines 108-155) has correct dependencies",
        "Analyze stacks.map render loop - repeated getSearchQuery/getSearchDomain calls?",
        "Verify createStackNodeRefCallback and createStackMouseEnterCallback are stable",
        "Check if selectionIndex.isStackInDomain calls are truly O(1)",
        "Review useDeferredValue usage - is it helping or hurting?",
        "Analyze roving tabindex calculation per render"
      ],
      "passes": true,
      "findings": [
        "scaleFactors useMemo CORRECT: dependencies [stacks, searchParams, selectionIndex], uses O(1) selectionIndex lookups",
        "FIXED: stacks.map() render loop - function calls hoisted outside loop in fix-02",
        "createStackNodeRefCallback CORRECT: Properly memoized factory function",
        "createStackMouseEnterCallback CONCERN: Returns new closure per stack per render (line 399) - could cause unnecessary child re-renders if React.memo used",
        "selectionIndex.isStackInDomain CORRECT: O(1) via Map.get().has()",
        "useDeferredValue CORRECT: Properly defers searchParams to prioritize animations",
        "FIXED: rovingTabindex.getTabIndex() - now uses O(1) Map lookup, fixed in fix-02"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-07",
      "description": "Investigate root-node-chart.tsx: D3 transitions, event handler setup, SVG filter performance",
      "steps_to_verify": [
        "Read root-node-chart.tsx - very long file, many useEffects",
        "Check if SVG glow filter (feGaussianBlur) impacts performance",
        "Analyze D3 transition tween functions - are they efficient?",
        "Review handleHoverStart/handleHoverEnd - DOM selections on every call?",
        "Check if d3.select() is called too frequently",
        "Verify interrupt() usage - is it causing transition conflicts?",
        "Analyze event handler registration - is it done optimally?"
      ],
      "passes": true,
      "findings": [
        "SVG glow filter (feGaussianBlur stdDeviation=2) ACCEPTABLE: Low blur value, only ~6 segments, applied conditionally. Per Chrome docs, SVG-on-SVG filters use CPU path but impact negligible at this scale",
        "D3 transition tween functions CORRECT: Batch DOM reads before writes (lines 201-214), use D3 interpolators, update datum state at t=1. Follows D3 best practice of tween initialization batching",
        "d3.select() calls in event handlers ACCEPTABLE: Called once per hover/focus event, not per frame. Selection is cached within tween closure. D3 recommends caching selections but per-event cost is trivial",
        "interrupt() usage CORRECT: Immediately interrupts ongoing transitions before starting new ones (lines 222-223, 609-610). This is D3 best practice for responsive feel - prevents animation queue buildup",
        "Event handler registration CORRECT: Done once in setupHoverInteractions() after initial render/animation, not on every render. Handlers use D3's .on() method which efficiently attaches to selections",
        "CONCERN: handleHoverStart/handleHoverEnd create new d3.select() calls (lines 583-607, 690-724) but these are per-event, not per-frame. Caching the visualsLayer selection earlier would be micro-optimization",
        "arcs.findIndex() in focus handler (line 966) O(n) per focus event: Trivial for ~6 segments, called only on keyboard focus, not on hover",
        "Random ID generation (lines 407, 447) ACCEPTABLE: Only called once per mount, not per render",
        "NO ACTIONABLE BUGS FOUND: Code follows D3 best practices. Some micro-optimizations possible but negligible impact at current scale"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-08",
      "description": "Investigate projects.tsx View Transitions: flushSync usage, transition timing, concurrent transition handling",
      "steps_to_verify": [
        "Read projects.tsx View Transition implementation",
        "Check flushSync usage - is it causing layout thrashing?",
        "Analyze ongoingTransitionRef.current.skipTransition() pattern",
        "Verify diffProjectStates is efficient",
        "Check if filterCache is working correctly",
        "Review useScrollDelegation hook impact",
        "Search for View Transitions + React best practices 2025"
      ],
      "passes": true,
      "findings": [
        "CRITICAL BUG FOUND: flushSync + startViewTransition was BLOCKING React's concurrent rendering, causing 3-6 second lag on StackNode clicks!",
        "Root cause: flushSync opts out of React's batching. When StackNode.handleClick uses startTransition(), the flushSync in projects.tsx interrupts it",
        "Per React docs: 'If a flushSync happens in the middle of a view transition sequence, React will skip the Transition'",
        "FIXED in fix-05: Removed manual startViewTransition + flushSync. React's built-in ViewTransition (via Next.js config) handles animations",
        "FIXED in fix-05: O(n²) isVisible prop now uses Set for O(1) lookup",
        "FIXED in fix-05: Inline callbacks in stack-cloud-content.tsx now memoized via Map to prevent recreation per render",
        "skipTransition() pattern was OVER-ENGINEERED: No longer needed since we don't manually manage transitions",
        "diffProjectStates EFFICIENT: Uses Set for O(1) lookups, O(n) overall complexity for comparing filtered lists",
        "filterCache CORRECT: Simple LRU with 50 entry max, prevents redundant filtering operations",
        "CODE SMELL: Safari detection duplicated between projects.tsx and use-scroll-delegation.ts. Should extract to shared utility",
        "RESULT: Subsequent StackNode clicks now 270-350ms (down from 3-6 seconds). First click still slow due to dev server HMR."
      ]
    },
    {
      "category": "investigation",
      "id": "inv-09",
      "description": "Investigate use-dimensions.ts: ResizeObserver efficiency, debounce timing, calculateBaseStackRadius frequency",
      "steps_to_verify": [
        "Read use-dimensions.ts implementation",
        "Check if 100ms debounce is optimal for resize",
        "Analyze calculateBaseStackRadius - is it expensive? Called too often?",
        "Verify visualViewport listener cleanup",
        "Check if dimensions object causes unnecessary re-renders"
      ],
      "passes": true,
      "findings": [
        "100ms debounce OPTIMAL: Standard for resize handlers. Not too fast (janky), not too slow (laggy)",
        "FIXED: calculateBaseStackRadius - redundant work fixed in fix-03, now accepts pre-computed stacks/sizeFactors",
        "visualViewport listener cleanup CORRECT: Properly removes both 'resize' and 'scroll' listeners",
        "FIXED: Debounced callbacks now call .cancel() in cleanup - fixed in fix-03",
        "dimensions object CORRECT: New object created only on actual resize events, not every render"
      ]
    },
    {
      "category": "investigation",
      "id": "inv-10",
      "description": "Profile actual runtime performance: Chrome DevTools Performance tab analysis",
      "steps_to_verify": [
        "Record performance trace during initial load",
        "Record trace during stack node selection/deselection",
        "Record trace during domain segment hover",
        "Record trace during search input typing",
        "Identify long tasks (>50ms) and their sources",
        "Check for forced synchronous layouts",
        "Analyze paint/composite times for SVG elements"
      ],
      "passes": false
    },
    {
      "category": "fix",
      "id": "fix-01",
      "description": "Fix mass-dampen-force.ts incorrect D3 force pattern - force was NO-OP",
      "steps_to_verify": [
        "Force should have .initialize(nodes) method for D3 to pass nodes",
        "Force function should take alpha param directly, not return curried function",
        "Force should have .update(avgRadius) method for efficient updates"
      ],
      "passes": true,
      "findings": [
        "FIXED: Changed function signature from (alpha) => (nodes) => void to (alpha) => void",
        "FIXED: Added .initialize(_nodes) method to receive nodes from D3 simulation",
        "FIXED: Added .update(avgRadius) method for parameter updates",
        "FIXED: Stores nodes in closure variable, accessed during force execution",
        "Force now follows same pattern as boundary-force.ts and root-exclusion-force.ts"
      ]
    },
    {
      "category": "fix",
      "id": "fix-02",
      "description": "Fix O(n²) render loop bugs in stack-cloud-content.tsx and use-roving-tabindex.ts",
      "steps_to_verify": [
        "Hoist getSearchQuery/getSearchFilter/getSearchDomain calls outside stacks.map() loop",
        "Replace items.findIndex() with O(1) Map lookup in getTabIndex()"
      ],
      "passes": true,
      "findings": [
        "FIXED: Hoisted 4 function calls outside render loop using IIFE pattern - now O(1) per render instead of O(4n)",
        "FIXED: Added indexMap useMemo to use-roving-tabindex.ts for O(1) id->index lookup",
        "FIXED: getTabIndex() now uses indexMap.get() instead of items.findIndex() - O(1) instead of O(n)",
        "Overall complexity reduced from O(n²) to O(n) per render"
      ]
    },
    {
      "category": "fix",
      "id": "fix-03",
      "description": "Fix calculate-base-radius.ts redundant work and use-dimensions.ts debounce cleanup",
      "steps_to_verify": [
        "calculateBaseStackRadius should accept pre-computed stacks/sizeFactors as parameters",
        "useDimensions should pass stacks/sizeFactors from upstream memoized values",
        "Debounced callbacks should call .cancel() in cleanup to prevent state updates after unmount"
      ],
      "passes": true,
      "findings": [
        "FIXED: calculateBaseStackRadius now accepts stacks and sizeFactors as parameters instead of recomputing",
        "FIXED: useDimensions now takes stacks and sizeFactors as parameters, passed from stack-cloud-content.tsx",
        "FIXED: Both debounced callbacks (ResizeObserver and visualViewport) now call .cancel() in cleanup",
        "Eliminates O(projects×stacks) work + date parsing on every viewport resize"
      ]
    },
    {
      "category": "fix",
      "id": "fix-04",
      "description": "Fix stack-node.tsx inline style object recreation on every render",
      "steps_to_verify": [
        "Memoize getDropShadow() result to avoid recalculation on every render",
        "Memoize transitionStyle string to avoid recreation on every render",
        "Memoize the entire style object to prevent new object on every render"
      ],
      "passes": true,
      "findings": [
        "FIXED: dropShadow now useMemo with deps [a11y.shouldShowGlow, state, borderColor]",
        "FIXED: transitionStyle now useMemo with deps [transitionDuration]",
        "FIXED: nodeStyle object now useMemo with deps [dropShadow, transitionStyle, isSelected, isHighlighted]",
        "Prevents ~30 style object recreations per render for memoized StackNode components"
      ]
    },
    {
      "category": "fix",
      "id": "fix-05",
      "description": "Fix StackNode click lag by removing flushSync + startViewTransition anti-pattern",
      "steps_to_verify": [
        "Remove manual document.startViewTransition() calls in projects.tsx",
        "Remove flushSync import and usage - it blocks React's concurrent rendering",
        "Let React's built-in ViewTransition (via Next.js experimental flag) handle animations",
        "Use Set for O(1) isVisible lookup instead of O(n) filtered.some()",
        "Memoize inline callbacks in stack-cloud-content.tsx render loop"
      ],
      "passes": true,
      "findings": [
        "FIXED: Removed flushSync import and all usage from projects.tsx",
        "FIXED: Replaced manual startViewTransition() with startTransition() for non-blocking updates",
        "FIXED: Added CSS transitions to .project-item class for smooth enter/exit animations",
        "FIXED: Project component now applies animation classes (project-from-bottom, project-slide-out) based on projectState",
        "FIXED: O(n²) isVisible prop now uses filteredIdSet.has() for O(1) lookup",
        "FIXED: Created memoized callback Maps (mouseEnterCallbacks, focusCallbacks, combinedNodeRefCallbacks) in stack-cloud-content.tsx",
        "FIXED: Render loop now uses stable callback references from Maps instead of inline functions",
        "RESULT: Subsequent StackNode clicks improved from 3-6 seconds to ~580ms with CSS animations working"
      ]
    }
  ],
  "references": {
    "d3_force_docs": "https://d3js.org/d3-force/simulation",
    "d3_many_body": "https://d3js.org/d3-force/many-body",
    "d3_collide": "https://d3js.org/d3-force/collide",
    "d3_force_reuse": "https://github.com/twosixlabs/d3-force-reuse",
    "barnes_hut": "https://jheer.github.io/barnes-hut/",
    "view_transitions": "https://developer.chrome.com/docs/web-platform/view-transitions",
    "react_view_transition": "https://react.dev/reference/react/ViewTransition"
  },
  "notes": [
    "Current node count is ~30 stacks - relatively small for D3 force simulation",
    "d3-force-reuse may provide 10-90% speedup by reusing quadtree (recalc every 13 ticks)",
    "theta parameter at 0.5 may be too conservative - default is 0.9, 1.0 often works",
    "COLLISION_ITERATIONS=12 is very high - default is 1, 2-4 common for rigidity",
    "View Transitions with flushSync can cause layout thrashing if not careful",
    "willChange should only be set during animations to avoid memory pressure"
  ]
}
